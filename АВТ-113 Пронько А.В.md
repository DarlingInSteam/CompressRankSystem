**РЕФЕРАТ**

Отчет 20 с., 1 кн., 8 источн., 0 рис., 0 табл., 0 прил.

ОБРАБОТКА ИЗОБРАЖЕНИЙ, АВТОМАТИЗАЦИЯ, JAVA, SPRING BOOT, POSTFRESQL, KAFKA, АЛГОРИМЫ СЖАТИЯ, КОНТЕЙНЕРЫ

В данной работе рассматривается разработка информационной системы для обработки изображений, целью которой является автоматизация процессов сжатия изображений с учетом их популярности, эффективное управление хранилищем данных и предоставление пользователям высококачественных изображений. Актуальность темы обусловлена необходимостью оптимизации хранения и передачи изображений, что особенно важно в условиях работы с большими объемами данных в современных информационных системах.

В первой главе рассматриваются основные требования к системе, включая функциональные и нефункциональные аспекты. Особое внимание уделяется надежности, производительности и адаптивности системы, поскольку эти параметры критически важны для работы с большими объемами изображений и их популярностью.

Во второй главе обоснован выбор инструментов и технологий для разработки системы обработки изображений. Описаны теоретические методы анализа данных и алгоритмов сжатия. В качестве основных технологий выбраны Java и Spring Boot для реализации серверной части приложения, PostgreSQL как система управления базами данных, Kafka для обработки событий, связанных с популярностью изображений, и библиотеки для сжатия данных с использованием форматов JPEG (с потерями) и PNG (без потерь).





**СОДЕРЖАНИЕ**

[ВВЕДЕНИЕ	3](#_toc195554515)

[1 Обзор предметной области	5](#_toc195554516)

[1.1 Актуальность проекта	5](#_toc195554517)

[1.2 Анализ существующих решений	6](#_toc195554518)

[1.3 Функциональные требования	8](#_toc195554519)

[1.4 Описание предметной области	9](#_toc195554520)

[1.5 Постановка задачи	12](#_toc195554521)

[2 Выбор инструментов для решения задачи	14](#_toc195554522)

[3 Разработка информационной системы	16](#_toc195554523)

[3.1 Проектирование базы данных	16](#_toc195554524)

[3.1.1 Определение целей и требований к БД	17](#_toc195554525)

[3.1.2 Обоснование выбора СУБД и ключевых решений	17](#_toc195554526)

[3.2 Разработка интерфейса информационной системы	24](#_toc195554527)

[3.2.1 Общая архитектура микросервисов	24](#_toc195554528)

[3.2.2 Административная панель	25](#_toc195554529)

[3.2.3 Динамика сжатия и статистика	28](#_toc195554530)

[**СПИСОК ИСПОЛЬЗОВАННЫХ ИСТОЧНИКОВ**	33](#_toc195554531)



























# <a name="_toc195554515"></a>**ВВЕДЕНИЕ**
Современные информационные системы сталкиваются с возрастающими объемами данных, значительная часть которых приходится на изображения. Это создает проблемы эффективного использования дисковых ресурсов и увеличивает финансовые затраты компаний на их хранение. Одним из способов решения данной задачи является применение технологий сжатия изображений, однако существующие подходы часто игнорируют особенности частоты доступа к данным.

Данная выпускная квалификационная работа посвящена разработке информационной системы сжатия и ранжирования изображений. Суть системы заключается в динамическом управлении компрессией изображений в зависимости от частоты их использования: изображения с высокой частотой запросов подвергаются минимальному сжатию для сохранения качества, тогда как редко запрашиваемые изображения сжимаются сильнее для экономии дискового пространства.

Цель работы — создание легко встраиваемой, отказоустойчивой и расширяемой системы с открытым исходным кодом, которая позволит оптимизировать использование дисковых ресурсов и снизить затраты компаний.

Реализация данного проекта предполагает создание микросервиса, функционирующего в качестве промежуточного слоя между пользователем и хранилищем изображений. Проект ориентирован на небольшие компании и стартапы, которые нуждаются в доступном решении для управления хранилищами. Открытость кода обеспечит гибкость и возможность адаптации системы под индивидуальные потребности.

Значимость работы заключается в предложении экономически выгодного решения, способного снизить затраты на хранение изображений, а также повысить эффективность обработки данных.

В рамках данной работы будут рассмотрены существующие подходы к сжатию и управлению изображениями, предложены методы ранжирования и алгоритмы сжатия, а также выполнено тестирование разработанной системы.

































1. # <a name="_toc183816427"></a><a name="_toc195554516"></a>**Обзор предметной области**
   1. ## <a name="_toc183816428"></a><a name="_toc195554517"></a>**Актуальность проекта**
      `	`В современных условиях цифровизации объём данных, генерируемых и хранящихся в информационных системах, возрастает экспоненциально, и значительную часть этих данных составляют именно изображения. По оценкам отраслевых экспертов, графический контент может достигать 70% общего объёма веб-трафика, причём доля мультимедиа продолжает расти из-за повсеместного внедрения высококачественных камер, мобильных устройств и технологий виртуальной реальности. Особенно остро вопрос оптимизации хранения возникает в сферах, где изображения играют ключевую роль:

- Электронная коммерция: фотографии товаров и промоматериалы – основа презентации продукции, напрямую влияющая на продажи;
- Медицина: высокоточные диагностические снимки, результаты визуализации (МРТ, КТ) занимают гигантские объёмы, но при этом любое критическое ухудшение качества может привести к неправильным диагнозам,
- Образование: иллюстрации, инфографика, обучающие материалы с обильным графическим контентом повышают наглядность, но требуют соответствующей инфраструктуры для быстрой загрузки и хранения,
- Развлечения и медиа: фотографии, графика для видеоигр, социальные сети, потоковые платформы – все эти сервисы содержат миллионы изображений, которые нужно не только хранить, но и эффективно доставлять пользователям.

  Увеличение объёмов изображений неизбежно влечёт за собой рост затрат на их хранение, передачу и обработку. Для сохранения конкурентоспособности бизнесу необходимо постоянно оптимизировать процессы хранения: без грамотной стратегии данные могут стать чрезмерно дорогим ресурсом, а скорость доступа к ним – неприемлемо низкой.

  Существующие методы (например, автоматическое архивирование или единообразное сжатие) зачастую не учитывают, что у разных изображений может быть различная ценность и частота использования. В результате важные и востребованные изображения рискуют потерять качество, а редкие – наоборот, занимают дисковое пространство без веских причин. Более того, «коробочные» решения крупных облачных провайдеров, таких как Amazon Web Services, хотя и предоставляют интеллектуальные механизмы распределения уровней хранения, обычно оказываются сложными и дорогими для небольших компаний, к тому же не дают возможности тонкой кастомизации.

  Предлагаемый в данном проекте подход к динамическому управлению уровнем сжатия в зависимости от частоты доступа к изображению решает сразу несколько проблем. Он позволяет:

- Снизить расходы на хранение, освобождая пространство за счёт агрессивного сжатия редко запрашиваемых файлов;
- Повысить производительность систем хранения, поскольку уменьшается общий объём передаваемых и обрабатываемых данных;
- Сохранить высокое качество там, где это действительно необходимо, оставляя популярные изображения почти без потерь;
- Предложить гибкую и открытую архитектуру, которая не требует дорогих лицензий и способна интегрироваться с любыми объектными хранилищами и микросервисными платформами.

  Дополнительным фактором, повышающим актуальность, становится растущий интерес к решениям с открытым исходным кодом, позволяющим адаптировать систему под индивидуальные потребности бизнеса без постоянных отчислений за лицензирование. Благодаря микросервисной архитектуре такой сервис легко масштабировать и встраивать в существующие экосистемы компаний, не ломая привычных процессов.

  Таким образом, представляемый проект адресует ключевые вызовы современной индустрии в области управления большими объёмами графических данных. Он предоставляет баланс между эффективностью использования ресурсов, простотой интеграции в любую инфраструктуру и возможностью поддерживать высокое качество изображений при минимальных затратах.
  1. ## <a name="_toc183816429"></a><a name="_toc195554518"></a>**Анализ существующих решений**
     Задача управления изображениями с учётом частоты доступа и объёмов хранения уже давно стоит перед многими организациями, и на рынке сформировался ряд подходов и продуктов. Однако при более детальном рассмотрении обнаруживается, что ни одно из существующих решений не предлагает полной совокупности функций, необходимых для небольших компаний или специфических инфраструктур, где требуется простая, гибкая и экономически эффективная система. Ниже описаны основные типы решений и их ограничения.

     **Интеллектуальные хранилища данных**. Одним из наиболее известных примеров является S3 Intelligent Tiering от Amazon Web Services, автоматически распределяющий объекты по разным уровням хранения (tiers) в зависимости от частоты их доступа. Идея заключается в том, что часто используемые файлы хранятся на «горячем» уровне, обеспечивающем быстрый доступ, а редко востребованные объекты «переезжают» на более дешёвые и медленные уровни.

     Несмотря на заманчивую концепцию, у данного решения есть ряд недостатков. Во-первых, стоимость использования может оказаться высокой для небольших компаний, особенно если они не могут точно предсказать объёмы и время хранения. Во-вторых, закрытый исходный код AWS не позволяет вносить кастомные правки и разворачивать систему за пределами экосистемы Amazon. В-третьих, отсутствует гибкость применения для других провайдеров или локальных хранилищ — фактически пользователь привязывается к конкретному облаку. Таким образом, хотя S3 Intelligent Tiering автоматизирует некоторые аспекты управления, оно не решает задачу именно компрессии изображений в зависимости от популярности, а лишь переключает уровень хранения.

     **Системы сжатия изображений**. Существует множество инструментов, специализирующихся непосредственно на сжатии файлов: утилиты вроде JPEGoptim, PNGquant или универсальный пакет ImageMagick, включающий разные алгоритмы сжатия и трансформации изображений. Они позволяют уменьшить размер файла, сохранив визуально приемлемое качество. Однако здесь отсутствует логика, которая анализирует, насколько часто к файлу обращаются, и подстраивает алгоритм или степень сжатия автоматически.

     Более того, подобные инструменты действуют, как правило, локально или однократно. Администратор запускает скрипт, который оптимизирует все картинки в каталоге, — но по окончании операции нет никакого «наблюдающего» модуля, который бы мониторил дальнейшую популярность файлов и перераспределял их между уровнями качества по мере изменения частоты доступа. Также подобные решения не интегрируются напрямую с объектными хранилищами и не учитывают микросервисную архитектуру, что усложняет масштабирование и автоматизацию в составе крупной системы.

     **Платформы управления изображениями**. Коммерческие облачные платформы — Cloudinary, Imgix и т. п. — предлагают более высокоуровневые возможности: они не только сжимают файлы, но и умеют динамически изменять размеры, накладывать фильтры, хранить разные версии изображений для мобильных и десктопных устройств и раздавать их через CDN. Такие платформы могут автоматически определять наилучший формат (например, WebP для Chrome и Safari), чтобы сократить трафик.

     Однако высокий порог входа по стоимости и ограниченность экосистемы затрудняют использование Cloudinary или Imgix в небольших компаниях, особенно если бизнес растёт непредсказуемо и бюджеты нельзя жёстко планировать. Кроме того, эти платформы, как правило, не допускают глубокой кастомизации, поскольку работают по схеме SaaS (Software as a Service). Если необходима интеграция со специфическим локальным хранилищем или особые алгоритмы сжатия, это не всегда возможно.

     **Самописные системы сжатия**. Некоторые организации создают собственные решения для обработки и хранения графических файлов. Плюс таких систем — возможность гибко подстраивать логику под конкретные бизнес-задачи: от нестандартных форматов до специфических правил компрессии для разных категорий изображений. Тем не менее, подобная разработка требует больших временных и финансовых вложений, наличия узкопрофильных специалистов (экспертов по алгоритмам сжатия, DevOps, системной интеграции) и постоянной поддержки кода. Кроме того, отсутствует модульная структура: когда всё пишется в одном проекте, это усложняет интеграцию с другими сервисами, обновления или масштабирование.

     Таким образом, существующие подходы либо слишком дорогие и зависят от экосистемы конкретного облачного провайдера (S3 Intelligent Tiering), либо нацелены лишь на одноразовую оптимизацию изображений (ImageMagick, JPEGoptim и т.п.), либо предлагают функционал, выходящий за рамки простого управления сжатием, но при этом недоступный небольшой компании из-за стоимости или архитектурных ограничений (Cloudinary, Imgix), либо требуют серьёзных внутренних ресурсов и не всегда модульны (самописные системы).

     Потребность же в универсальном решении, которое могло бы автоматически анализировать популярность файлов и динамически менять степень их сжатия при сохранении высокого качества популярных изображений, остаётся невыполненной. Именно это делает разрабатываемый проект востребованным: он нацелен на то, чтобы соединить преимущества автоматики (подобной S3 Intelligent Tiering) с гибкостью в работе со сжатием, доступностью исходного кода и возможностью локального развертывания.
  1. ## <a name="_toc183816430"></a><a name="_toc195554519"></a>**Функциональные требования**
     Данная система призвана автоматически управлять сжатием и хранением изображений на основе их популярности, обеспечивая гибкость, высокую производительность и простой интерфейс взаимодействия. Ниже перечислены ключевые функциональные области, которые система должна покрывать, с дополнительными пояснениями к каждой.

     **Сжатие изображений**:

- Различные уровни компрессии. Система должна уметь настраивать степень сжатия (или выбор алгоритма) в зависимости от того, насколько часто к файлу обращаются. Например, популярные изображения сжимать минимально, а редко просматриваемые — более агрессивно;
- Сохранение качества. Несмотря на способность ужимать файлы, система обязана обеспечивать визуально приемлемый результат, особенно когда речь идёт о критически важных снимках (медицинских, рекламных и т.д.). Алгоритмы должны балансировать между уменьшением объёма и сохранением деталей.

**Ранжирование изображений**:

- Учёт частоты использования. Система должна собирать и анализировать статистику обращений к каждому файлу (просмотры, скачивания) за определённый период. На основе этой статистики принимается решение об уровне компрессии;
- Динамическое изменение статуса. Изображения условно делятся на «часто используемые» и «редко используемые», причём их категория может меняться со временем. Система автоматически перемещает файлы из одной категории в другую, при необходимости пересжимая их.

  **Хранение данных**:

- Интеграция с объектными хранилищами. Для удобства пользователь может выбрать Amazon S3, MinIO или любое другое совместимое решение, а также локальные файловые системы. Этот выбор зависит от того, где и как планируется развернуть систему;
- Разделение уровней хранения. В некоторых инфраструктурах выгодно иметь несколько «слоёв» хранилища. «Горячий» слой для востребованных файлов (быстрый, но дорогой) и «холодный» для тех, к которым обращаются редко. Система должна поддерживать логику подобных перемещений.

  **Отказоустойчивость**:

- Гарантия сохранности данных. Изображения не должны пропадать при сбоях — например, при отключении сети или падении части серверов. Этот аспект особенно важен в среде, где обрабатываются критические файлы.
- Обработка ошибок. Предусматривается логирование (запись в журнал) всех ошибок, связанных со сжатием или обращениями к хранилищу, и их корректная обработка, чтобы система могла продолжить работу или уведомить администратора.

  **Расширяемость**:

- Добавление новых алгоритмов. Если в будущем появятся улучшенные методы сжатия (например, более эффективные варианты WebP, HEIC, AVIF и т.п.), система должна позволять легко подключать их без кардинальной перестройки всего приложения;
- Поддержка различных форматов. JPEG, PNG, WebP и другие — пользователи могут выбирать или автоматически определять наиболее подходящий формат для конкретной задачи. Если потребуется, можно добавить новые.

  **Автоматизация**:

- Планировщик задач. Важной частью является планирование пересжатия и обновления статусов. Система должна автоматически, скажем, раз в сутки анализировать файлы и решать, нужно ли повысить или понизить уровень компрессии;
- Уведомления. При возникновении ошибок (например, неудачная попытка пересжать изображение, отключённое хранилище) или при завершении массовых операций, администратор получает соответствующие сообщения (по электронной почте, в мессенджере, через внутренний лог и т.д.).

  **Микросервисная архитектура**:

- REST API. Взаимодействие с системой должно происходить через стандартные веб-протоколы, чтобы упростить интеграцию с другими сервисами (например, вэб-интерфейсом, мобильным клиентом). Открытый интерфейс позволяет подключать и внешние приложения, если необходимо;
- Документация API. Чтобы разработчики без труда могли разобраться, как загружать новые файлы, как запрашивать статистику и т.д., необходимо поддерживать в актуальном состоянии описание всех доступных методов.
  1. ## <a name="_63pn4cipoyij"></a><a name="_toc183816431"></a><a name="_toc195554520"></a>**Описание предметной области**
     В последние годы количество цифровых изображений, создаваемых и обрабатываемых в самых разных областях, стремительно растёт. Это связано не только с прогрессом в сфере искусственного интеллекта, машинного обучения и интернета вещей (IoT), но и с глобальной цифровизацией общества: всё больше информации, ранее представленной в виде текстов или статистических отчётов, теперь дополняется или полностью заменяется визуальными материалами. Социальные сети, облачные фотохостинги, медицинские системы PACS, онлайн-магазины и обучающие платформы — все они генерируют огромные массивы изображений, которые зачастую необходимо обрабатывать, передавать и хранить в разных форматах.

     Ключевая сложность заключается в том, что изображения представляют собой один из самых «тяжёлых» видов данных. Их общий объём в информационной системе может многократно превышать объём текстовых или структурированных записей. При использовании облачных хранилищ или крупных корпоративных серверов этот объём нередко достигает масштабов терабайт и петабайт, что порождает весьма ощутимые затраты на аренду ресурсов и поддержание необходимого уровня быстродействия.

     Для решения такой проблемы на практике часто применяют сжатие данных. Оно действительно способно существенно уменьшить размер файлов, однако в случае изображений не всегда очевидно, какую степень компрессии следует выбирать, чтобы не нанести критический ущерб качеству. Одно дело, когда речь идёт о снимках, к которым очень редко обращаются (скажем, архивный контент), и совсем другое — когда это фотографии товаров в интернет-магазине, напрямую влияющие на конверсию или медицинские снимки, требующие высокой точности передачи деталей.

     Различают два типа сжатия изображений:

- ` `Без потерь (lossless): воссоздаёт исходную картинку пиксель в пиксель, но не даёт столь существенной экономии места.
- ` `С потерями (lossy): может в разы уменьшить файл, однако при неаккуратном применении приводит к заметным артефактам или смазыванию деталей.

  В условиях, когда доступ к одним и тем же изображениям может сильно меняться (например, новые фотографии становятся внезапно популярными, старые — почти не просматриваются), встаёт вопрос динамического управления уровнем компрессии. Простой подход «всегда максимальное сжатие» или «всегда без потерь» перестаёт работать, так как либо пользователи получают низкое качество там, где оно важно, либо организация теряет ресурсы, храня огромные «пустые объёмы».

  Ранжирование изображений по частоте доступа призвано решить эту дилемму. Идея в том, чтобы анализировать, насколько часто к файлу обращаются (просмотры, скачивания) и на основании этого автоматически переключать режим сжатия. Если файл редко запрашивают, его можно перевести в «агрессивное сжатие», а если его популярность вдруг выросла, вернуть более высокое качество. Это позволяет оптимизировать как объёмы хранения, так и скорость доступа, ведь размер файла напрямую влияет на время его передачи по сети.

  Ещё один важный аспект предметной области — интеграция с объектными хранилищами. Популярные решения (Amazon S3, Google Cloud Storage, MinIO и др.) уже умеют масштабироваться и выдерживать большие нагрузки, но не имеют встроенных механизмов «умного» сжатия именно по частоте использования. Следовательно, возникает потребность в системе-прослойке, которая контролирует степень компрессии изображений и взаимодействует с хранилищем по стандартным API.

  При этом нельзя забывать о вопросах отказоустойчивости. В условиях больших объёмов данных отказ одного сервиса или одного узла хранилища не должен приводить к недоступности всего массива изображений. Аналогично, при масштабировании на сотни тысяч файлов в сутки, система компрессии и ранжирования должна без проблем перерабатывать всю поступающую статистику, не снижая производительность.

  В результате формулируются основные задачи:

- Эффективное использование дискового пространства: за счет динамического сжатия изображений, система позволяет экономить пространство на сервере и снижать расходы на хранение;
- Повышение скорости доступа к данным: за счет различного уровня сжатия изображений система позволяет обеспечивать быстрый доступ к данным с минимальными затратами ресурсов;
- Умная интеграция с облачными хранилищами: система должна легко интегрироваться с популярными объектными хранилищами и предоставлять API для работы с изображениями;
- Масштабируемость и отказоустойчивость: система должна эффективно работать при увеличении количества данных и запросов, а также быть готовой к восстановлению после сбоев;
- Поддержка различных форматов сжатия (JPEG, PNG, WebP, и возможность добавлять новые).

  Таким образом, предметная область охватывает методы оптимизации хранения и обработки больших объёмов изображений с учётом частоты их использования. Создаваемая система становится крайне актуальной в любых высоконагруженных средах: от розничных интернет-магазинов до медицинских архивов и социальных платформ, где важны как экономия ресурсов, так и высокое качество визуальных данных.

  Разработка такой системы будет способствовать значительному улучшению качества обслуживания пользователей, снижению затрат на хранение данных, а также обеспечит высокую производительность при масштабировании инфраструктуры. Подобные решения востребованы в различных отраслях, включая интернет-магазины, социальные сети, платформы для хранения медиа-контента и другие сервисы, которые активно используют изображения в своей работе.
  1. ## <a name="_toc195554521"></a>**Постановка задачи**
     `	`Для создания данной системы, способной автоматически управлять сжатием и ранжированием изображений на основе их популярности, требуется решить комплекс задач, охватывающих как исследовательско-проектный этап, так и практическую реализацию микросервисной архитектуры.

     **Исследование предметной области**:

- ` `Анализ требований к системе. Необходимо детально изучить особенности хранения и обработки изображений в разных сценариях (электронная коммерция, социальные сети, медицина и т.д.), чтобы учесть различия в частоте обращений и критичности качества.
- ` `Определение критериев популярности изображений. Следует выбрать метрики (число просмотров, скачиваний, лайков или иное) и периоды (сутки, неделя), чтобы точно оценивать спрос.
- ` `Исследование существующих алгоритмов сжатия. Нужно сравнить безпотерьные (PNG, WebP без потерь) и с потерями (JPEG, WebP, HEIC, AVIF) методы, а также сформировать политику, в каких случаях применять более агрессивное сжатие.

**Проектирование системы**:

- ` `Разработка архитектуры микросервисного приложения. Основные подсистемы: хранение (интеграция с MinIO, S3 или локальным файлом), анализ популярности (с учётом Kafka или другого брокера), модуль сжатия (выбор алгоритма на основе популярности).
- ` `Определение структуры базы данных (PostgreSQL). Нужно спроектировать таблицы для метаданных о файлах (размер, уровень сжатия), статистики обращений (viewCount, downloadCount), а также для административных данных (пользователи, роли, если это предусмотрено).
- ` `Логика ранжирования изображений. Выбор и реализация алгоритма, который принимает на вход показатели популярности и решает, какое сжатие нужно применить для конкретного файла.

  **Реализация подсистемы хранения данных**:

- ` `Настройка PostgreSQL. Предусмотреть грамотную схему хранения, индексы для быстрого поиска и масштабируемость, если объёмы изображений и пользователей будут расти.
- ` `Проектирование таблиц. Нужно обеспечить удобную связь между «карточкой» изображения и его статистикой, а также хранить сведения о текущем уровне компрессии.

  **Реализация подсистемы обработки изображений**:

- ` `Имплементация алгоритмов сжатия с потерями и без (JPEG, PNG, WebP и т.д.). Следует определить, какой формат и алгоритм использовать в том или ином случае, возможно, давая администратору право выбора.
- ` `Интеграция библиотек для работы с изображениями на базе Spring Boot. Может понадобиться ImageIO (Java), libwebp или другие инструменты. Важно обеспечить совместимость и высокую производительность.
- ` `Функциональность автоматического выбора метода сжатия. Модуль должен, опираясь на данные о популярности, «переводить» изображения в нужную степень компрессии, а при необходимости восстанавливать их из «более качественной» копии.

  **Реализация подсистемы анализа популярности**:

- ` `Интеграция с Kafka (или другим брокером сообщений). Система событийного учёта обращений к файлам должна складывать факты использования в поток, чтобы можно было асинхронно их подсчитывать.
- ` `Разработка алгоритмов подсчёта популярности и логики обновления рейтинга. Нужно формализовать, за какой период и как часто пересчитывать «рейтинг», а затем обновлять в базе ссылку на уровень сжатия.

  **Создание пользовательского интерфейса и API**:

- ` `Проектирование REST API. Важно иметь стандартные методы для загрузки, получения, удаления и пересжатия изображений, а также для просмотра статистики и настроек компрессии.
- ` `Удобный интерфейс для администраторов и пользователей. Предусматривается графический интерфейс (GUI) или веб-приложение, где можно видеть списки файлов, их популярность, текущий уровень сжатия и управлять процессом вручную при необходимости.

  **Тестирование и отладка**: 

- ` `Модульное и интеграционное тестирование. Каждая подсистема (хранение, аналитика, компрессия) проверяется сначала по отдельности, а затем в связке, чтобы убедиться в корректном взаимодействии.
- ` `Проверка корректности алгоритмов сжатия, подсчёта популярности и работы с Kafka. Нужно убедиться, что система не теряет события, корректно обрабатывает ошибки и действительно повышает/понижает уровень компрессии в нужный момент.

  **Развертывание системы**:

- ` `Настройка среды. Включает конфигурирование PostgreSQL, запуск брокера Kafka и настройку Spring Boot-сервисов. Нужно обеспечить единый docker-compose или Kubernetes-манифесты, позволяющие легко поднять все компоненты.
- ` `Подготовка инструкций. Требуется описать пошаговое развертывание (с учётом версий JVM, PostgreSQL, Kafka), чтобы любой желающий мог воспроизвести окружение.

  **Документирование решения**:

- ` `Подготовка технической документации. Диаграммы архитектуры, схемы баз данных, описание основных модулей и API, чтобы разработчикам и администраторам было проще разобраться в устройстве системы.
- ` `Руководство пользователя. Включает описание интерфейса, инструкции по добавлению изображений, управлению уровнями сжатия, работе со статистикой и устранению типовых проблем.

  Таким образом, успешная реализация вышеуказанных пунктов позволит создать масштабируемую, гибкую и удобную систему, которая динамически регулирует степень сжатия изображений и оптимизирует хранение, обеспечивая высокий уровень качества популярных файлов и экономию ресурсов там, где это возможно.
2

1. # <a name="_toc183816432"></a><a name="_toc195554522"></a>**Выбор инструментов для решения задачи**
   <a name="_toc183816433"></a>**2.1 Теоретические методы**

   Для разработки системы сжатия и ранжирования изображений было решено комбинировать как фундаментальные подходы к проектированию ПО, так и специфические знания из области сжатия графики. В первую очередь необходимо учитывать, что система должна соответствовать требованиям пользователей (как функциональным, так и нефункциональным) и обеспечивать сохранность данных при минимизации занимаемого места на диске:

   `	`Этот метод позволяет выявить ключевые потребности всех заинтересованных сторон. Для его применения могут использоваться интервьюирование потенциальных администраторов, анкетирование конечных пользователей, а также сравнение с существующими решениями. Такие исследования помогают сформулировать четкие цели (например, допустимые задержки при обращении к файлам, уровень допускаемых потерь качества) и установить приоритетные функции (частичная или полная автоматизация сжатия, использование разных форматов);

   `	`Проектирование систем. Принципы как структурного, так и объектно-ориентированного проектирования применяются для построения чёткого представления о том, как различные компоненты (микросервисы) будут взаимодействовать. Модульность и отказоустойчивость особенно важны: в микросервисной архитектуре отдельные сервисы могут временно «отваливаться», и система должна уметь продолжать работу. Поэтому к базовым методам проектирования добавляется упор на продвинутые аспекты вроде шаблонов проектирования (паттернов), рассчитанных на распределённые системы;

   `	`Тестирование. Чтобы проверить корректность решения и не допустить существенных регрессий, применяются различные уровни тестов: модульные, интеграционные и системные. Модульные тесты помогают изолированно проверять функции (например, алгоритмы сжатия), интеграционные – убедиться, что микросервисы корректно взаимодействуют с СУБД и MinIO, а системные – что вся система в сборе отвечает требованиям. Дополнительно может предусматриваться нагрузочное тестирование (проверка масштабируемости) и «chaos testing» (проверка устойчивости к отказам);

   `	`Важным моментом остаётся понимание используемых технологий не только «в ширину», но и «в глубину». К примеру, знание тонкостей Spring Boot и PostgreSQL позволяет оптимизировать работу с базой, избежать «тяжёлых» запросов и грамотно настроить кэширование. То же самое касается алгоритмов сжатия изображений: каждой небольшой оптимизацией можно добиться улучшения производительности сервиса и экономии дисковых ресурсов.

   `	`Таким образом, совокупность данных методов формирует теоретическую базу, на которой строится весь жизненный цикл разработки системы сжатия и ранжирования изображений.

   <a name="_toc183816434"></a>**2.2 Сведения из предметной области**

   Разработка системы сжатия и ранжирования изображений предполагает не только знание общих принципов разработки ПО, но и глубокое понимание особенностей обработки графических файлов, распределённых систем и сетевых нагрузок.

   <a name="_toc183816435"></a>Вопросы компрессии изображения затрагивают как алгоритмы с потерями (JPEG, WebP), так и алгоритмы без потерь (PNG). На практике выбор формата и уровня сжатия зависит от того, насколько важна детализация: для редко просматриваемых изображений допустимо агрессивное уменьшение размера, тогда как «популярные» файлы лучше хранить почти без потерь. При этом часть изображений (например, содержащих текст или важные мелкие детали) может требовать совсем иных подходов, чтобы информация не терялась.

   Неотъемлемым аспектом является микросервисная архитектура. В распределённой среде нужно уметь балансировать нагрузку, настраивать сервис на автоматическое масштабирование и учитывать принцип eventual consistency («конечная согласованность»). Это накладывает требования на структуру хранения данных (реляционная модель, NoSQL или их гибрид), а также на взаимодействие с брокерами сообщений (Kafka, RabbitMQ), если планируется асинхронная обработка статистики. Уровень надёжности сильно зависит от того, как микросервисы будут обрабатывать сбои в сети, падения отдельных узлов и т. п.

   Подобная система, ориентированная на высокие запросы к изображениям, требует внимания к балансировке: если сервис сжатия внезапно станет узким местом, или база «не потянет» нагрузку, результатом может стать ухудшение пользовательского опыта. Знание ключевых параметров каждого модуля, от CPU до сетевого стека, помогает заранее избежать проблем с производительностью.

   **2.3 Инструменты для реализации проекта**

   С учётом обозначенных теоретических методов и предметной специфики, была выбрана комбинация инструментов, позволяющих максимально эффективно решить задачу сжатия и ранжирования изображений в микросервисной среде.

   `	`Язык программирования (ЯП). Основой для проекта служит Java, прежде всего из-за её платформенной независимости и широкой экосистемы. Этот язык хорошо оптимизирован и позволяет развернуть сервис как на Linux, так и на Windows-серверах. Более того, Java предоставляет множество библиотек для работы с графикой, а Spring Boot существенно упрощает процесс создания микросервисов. Если в будущем сервис будет расширяться, Java-экосистема (JPA, Hibernate, Spring Security) облегчит внедрение новых функций без радикальной смены стека.

   `	`Система управления базами данных (СУБД). Реляционная база PostgreSQL выбрана благодаря сочетанию стабильности, быстрого развития и поддержки расширенных возможностей (например, JSONB, что может пригодиться при хранении дополнительных метаданных). Для решения задачи ранжирования полезны оконные функции, позволяющие удобно агрегировать и фильтровать статистику (например, последние семь дней). PostgreSQL также имеет активное сообщество, что упрощает поиск решений в случае нестандартных проблем.

   `	`Система контроля версий. Система Gerrit предоставляет удобные инструменты для работы с ветками, коммитами, ревью кода и пулл-реквестами. Такой подход гарантирует, что все изменения в проекте проходят проверку и обсуждение, а история становится более наглядной. Вне зависимости от выбора конкретной платформы (Gerrit, GitHub, GitLab), принцип остается тот же: контроль версий повышает надёжность разработческого процесса и упрощает коллективную работу.

   `	`Spring Boot считается своего рода «стандартом де-факто» для микросервисной разработки на Java. Он включает в себя уже настроенные зависимости (Spring MVC, Spring Data, Spring Security) и позволяет запускать сервисы буквально в пару строк кода. В контексте сжатия и ранжирования это особенно полезно: можно быстро связать бизнес-логику с хранилищем MinIO или с базой PostgreSQL, организовать REST API для доступа к статистике и изображениям, а также встроить механизмы безопасности с JWT.

   `	`Алгоритм сжатия изображений. В проекте предусмотрено автоматическое преобразование всех загруженных файлов в формат WebP, поскольку он сочетает сильные стороны без потерь (аналогичные PNG) и с потерями (как в JPEG), что делает его универсальным решением для подавляющего большинства изображений. При этом реализована шкала сжатия в диапазоне от 0 до 100: для часто используемых (и критически важных) файлов выставляется низкий уровень компрессии (ближе к 0), а для редко просматриваемых — более высокий (до 100), что обеспечивает значительную экономию места. Важно отметить, что система поддерживает восстановление исходного качества, храня или «привязывая» ссылку на базовую (минимально сжатую) версию, чтобы при всплеске популярности можно было вернуть оптимальное соотношение визуального качества и размера.

   Таким образом, выбор WebP объясняется необходимостью единообразного подхода к файлам: нет смысла переключаться между PNG и JPEG, когда WebP предлагает возможности и без потерь, и с ними, плюс даёт неплохую компрессию даже при высоких настройках качества. Java и Spring Boot дают свободу развивать микросервисную архитектуру, PostgreSQL обеспечивает гибкие возможности хранения и статистического анализа, а Gerrit повышает прозрачность командной работы. Алгоритмы сжатия, реализованные на базе WebP и управляемые 0–100-балльной шкалой, позволяют хранить «горячие» (часто используемые) изображения фактически без заметных потерь, а «холодные» (редкие) файлы — в более компактном виде.
1. # <a name="_toc195554523"></a>**Разработка информационной системы**
   1. ## <a name="_toc195554524"></a>**Проектирование базы данных**
      Проектирование структуры базы данных является важнейшим этапом разработки информационной системы, поскольку именно здесь определяется, какие данные и в каком формате будут храниться. Ключевая задача проекта — реализовать функционал сжатия изображений (с учётом их популярности), а также систему ролей и JWT-аутентификации для административной панели.

      В контексте проекта от базы данных требуется следующее:

- ` `Хранить изображения (или, точнее, их метаданные и ссылки на объекты в MinIO),
- ` `Учитывать популярность (статистика просмотров и скачиваний) для динамического управления уровнем сжатия,
- ` `Реализовывать систему ролей и JWT-аутентификацию для административной панели,
- ` `Обеспечивать целостность данных, расширяемость и надёжность.

  Для выполнения этих требований определили ключевые сущности и взаимосвязи между ними. Ниже описаны основные подходы и критерии, которые легли в основу проектирования.
  ### <a name="_toc195554525"></a>**3.1.1 Определение целей и требований к БД**
  Прежде чем приступить к созданию таблиц, необходимо сформировать список бизнес-требований, отражающих назначение системы:

- ` `Сжатие изображений: нужно хранить уровень сжатия (compressionLevel), а при необходимости иметь ссылку на «оригинал» (чтобы можно было вернуть исходное качество).
- ` `Учёт статистики: система должна подсчитывать просмотры, скачивания, хранить даты последних обращений. Это позволит анализировать популярность и автоматически менять качество изображения.
- ` `Разделение доступа: требуется хранить пользователей (логин, пароль), поддерживать роли (ADMIN, USER и т.д.), чтобы разграничить, кто имеет право удалять, переименовывать или сжимать изображения вручную.
- ` `Расширяемость: в будущем могут добавляться новые роли (например, REVIEWER), новые состояния сжатия (например, различная степень компрессии), новые показатели популярности. Структура БД должна легко поддерживать эти улучшения.

  На основании данных потребностей выделены пять таблиц — images, image\_statistics, users, roles, user\_roles. Две из них (images, image\_statistics) обеспечивают хранение и обработку мультимедийной части, а три дополнительные (users, roles, user\_roles) покрывают задачу JWT-аутентификации и управления ролями.
  ### <a name="_toc195554526"></a>**3.1.2 Обоснование выбора СУБД и ключевых решений**
  В качестве СУБД выбрана PostgreSQL, поскольку она:

- ` `Надёжна и широко применяется для высоконагруженных проектов,
- ` `Имеет расширенную функциональность (работа с JSONB, оконные функции, триггеры, partitioning),
- ` `Легко интегрируется со Spring Boot (через Spring Data JPA),
- ` `Активно развивается и имеет большое сообщество [1].

  Помимо PostgreSQL, альтернативой могла стать MySQL или Oracle Database; однако PostgreSQL в последнее время популярна именно благодаря богатеющему функционалу и хорошей совместимости с микросервисными архитектурами.

  Разделение логики метаданных и статистики. images хранит статические свойства (ID, имя файла, дата загрузки, уровень сжатия), а image\_statistics аккумулирует динамические показатели (viewCount, downloadCount, lastViewedAt). Такой подход позволяет оптимизировать чтение/запись статистики отдельно от метаданных, а также даёт гибкость в развитии (например, добавить в статистику ещё один тип событий).

  Поддержка динамического сжатия. Поле compressionLevel даёт возможность гибко определять степень компрессии. Поле originalImageId даёт ссылку на исходную запись, если текущий объект является «сжатой копией». Это позволяет при необходимости вернуть полное качество для популярных изображений.

  Система ролей для JWT. Users хранит учётные записи, roles содержит названия ролей (ADMIN, USER и т. д.), user\_roles связывает пользователя с несколькими ролями (модель «многие-ко-многим»). При входе пользователь получает JWT, в котором перечислены все его роли. Административные операции доступны только при наличии роли ADMIN [2]. 

  Минимизация избыточности. Некоторая информация (например, последний доступ) хранится как в images.lastAccessed, так и в image\_statistics.lastViewedAt/lastDownloadedAt. Важно не дублировать логику: lastAccessed обновляется при каждом просмотре/скачивании, а подробная статистика (viewCount, downloadCount) — в отдельной таблице. Такая организация создаёт баланс между производительностью и удобством.

  Возможность масштабирования. Таблицы спроектированы так, чтобы при росте объёмов данных можно было использовать шардинг, репликацию или partitioning (особенно актуально для image\_statistics). PostgreSQL предоставляет инструменты, упрощающие масштабирование без существенных изменений в схеме.

  **3.1.3 Структура сущностей и взаимосвязи**

  На рисунке 2.1 представлена ER-диаграмма, где: 

- ` `images ↔ image\_statistics: связь «1:1» по полю imageId,
- ` `users ↔ roles: связь «many-to-many» через промежуточную таблицу user\_roles,
- ` `compressionLevel в images отражает степень сжатия (0 = без компрессии, 1 = стандарт, 2 = высокая и т. д.),
- ` `originalImageId может указывать на другую запись в images, сохраняя цепочку «исходный файл → копия».

  ![Изображение выглядит как текст, диаграмма, снимок экрана, Параллельный

Контент, сгенерированный ИИ, может содержать ошибки.](Aspose.Words.2a035dbb-cfc3-4f17-912d-f297c388dd68.001.png)

  *Рис. 3.1 – ER-диаграмма базы данных с учётом JWT-аутентификации и динамического сжатия*

  Также на рисунке 2.2 представлена физическая модель базы данных.

  ![Изображение выглядит как текст, снимок экрана, число, программное обеспечение

Контент, сгенерированный ИИ, может содержать ошибки.](Aspose.Words.2a035dbb-cfc3-4f17-912d-f297c388dd68.002.png)

  *Рис. 3.2 Физическая модель базы данных с учётом JWT-аутентификации и динамического сжатия*

  Чтобы наглядно показать поля и типы данных, в таблице 2.1 кратко обобщены основные сущности.

  Таблица 2.1 – Перечень основных таблиц и их назначение

  |№|Сущность|Назначение|
  | - | - | - |
  |1|images|Содержит метаданные изображений (имя, тип, размер, уровень сжатия, время загрузки)|
  |2|image\_statistics|Учёт просмотров/скачиваний; связь «1 к 1» с images|
  |3|users|Учетные записи пользователей (логин, пароль, email), используется для JWT|
  |4|roles|Список доступных ролей (ADMIN, USER и т.п.)|
  |5|user\_roles|Таблица связи между users и roles, модель «многие-ко-многим»|

  Ниже представлена характеристика атрибутов (таблица 2.2), отражающая типы данных, ключи и краткое назначение каждого поля.

  |№|Сущность|Атрибут|Тип (домен)|Назначение|
  | - | - | - | - | - |
  |1|images|Идентификатор |Текст(20)|Уникальный идентификатор изображения (первичный ключ)|
  |||Название оригинального файла|Текст(20)|Исходное имя файла|
  |||Формат контента|Текст(60)|MIME-тип (например, image/png)|
  |||Название объекта|Текст(40)|Имя объекта в MinIO (S3-ключ)|
  |||Размер |Целое(3)|Размер файла (в байтах)|
  |||Уровень компрессии|Целое(3)|Текущий уровень сжатия (0 – без сжатия, 1 – умеренное и т.д.)|
  |||Дата загрузки|Дата(10)|Дата/время загрузки|
  |||Последнее обращение|Дата(10)|Дата/время последнего обращения к файлу|
  |||Кол-во обращений за неделю|Целое(3)|Общее число обращений (просмотров+скачиваний)|
  |||Название оригинального файла (если имеется)|Текст(20)|Ссылка на исходное изображение (если текущее является копией)|
  |2|image\_statistics|Ключ|Текст(20)|Внешний ключ, первичный ключ (1:1 с images)|
  |||Просмотры|Целое(3)|Количество просмотров|
  |||Скачивания|Целое(3)|Количество скачиваний|
  |||Последний просмотр|Дата(10)|Время последнего просмотра|
  |||Последнее скачивание|Дата(10)|Время последнего скачивания|
  |3|users|Идентификатор|Текст(20)|Уникальный идентификатор пользователя|
  |||Логин|Текст(20)|Логин (уникальное имя)|
  |||Пароль|Текст(20)|Хэш пароля|
  |||Почта|Текст(25)|Электронная почта|
  |||Время создания|Дата(10)|Дата/время регистрации|
  |4|roles|Идентификатор|Целое(3)|Уникальный идентификатор роли|
  |||Название|Текст(20)|Название роли (ADMIN, USER и др.)|
  |5|user\_roles|Ключ|Текст(20)|Ссылка на пользователя|
  |||Ключ|Целое(3)|Ссылка на роль|
  |||Дата назначения роли|Дата(10)|Дата/время назначения роли|

  Таким образом, в БД появляется 5 таблиц. Сущности images и image\_statistics позволяют хранить и анализировать популярность изображений, а связка users–roles–user\_roles обеспечивает реализацию JWT-аутентификации и разграничения прав.
  1. ## <a name="_toc195554527"></a>**Разработка интерфейса информационной системы**
     ### <a name="_toc195554528"></a>**3.2.1 Общая архитектура микросервисов**
     Система спроектирована на основе стрессоустойчивы и расширяемых микросервисов. Задача стрессоустойчивости является первичной в следствии того, что сжатие очень ресурсоемкий процесс, так что необходимо сделать так, чтобы процесс хорошо распределялся и при неудаче мог делегироваться в менее занятые области машины, на которой будет работать микросервис. Рассмотрим строение.

     Микросервис хранения и сжатия — сохраняет файлы в MinIO, записывает метаданные в таблицу images, меняет compressionLevel по запросам. Поддерживает встраивание новых алгоритмов сжатие по средствам внедрения jar проектов. Основан на рефлексии, чтобы поддерживать максимальное количество алгоритмов сжатия как с потерями, так и без потерь.

     Микросервис статистики — обновляет image\_statistics (просмотры, скачивания), решает, какие файлы сжимать/распаковывать в зависимости от популярности. Основополагающий микросервис для ранжирования. Собирает необходимую статистику по изображениям, инкапсулирует ее в нужной таблице. Имеет расписание, настраиваемое в админ панели для изменения настроек сбора и очищения.

     Микросервис аутентификации — работает с таблицами users, roles, user\_roles, формирует JWT с учётом ролей, проверяет доступ. Предназначен для строго распределения задач в рамках взаимодействия с админ панелью. Помогает модерировать контент ограниченному количеству людей.

     Административная панель — фронтенд или отдельный сервис, позволяющий управлять пользователями (назначать роли) и изображениями (удалять, переименовывать, дублировать и т.д.). Web решение для администраторов, создано для модерирования и отслеживания процессов. Имеет в себе возможность взаимодействовать с микросервисами и их настройками, а также просматривать метрики нагрузки и отслеживать alert сообщения.

     При входе пользователь вводит логин/пароль, сервис находит его запись в users, получает роли из user\_roles → roles, затем формирует JWT-токен. Для админских операций (каталог, сжатие, удаление) проверяется, есть ли у пользователя роль ADMIN [2]. Схема архитектуры представлена на рисунке 3.3.

     ![Изображение выглядит как диаграмма, линия, График, Параллельный

Контент, сгенерированный ИИ, может содержать ошибки.](Aspose.Words.2a035dbb-cfc3-4f17-912d-f297c388dd68.003.png)

     *Рис. 3.3 – Схема архитектуры проекта.*
     ### <a name="_toc195554529"></a>**3.2.2 Административная панель**
     Админ-панель — важная часть системы, она предоставляет UI, позволяющий с минимальными усилиями контролировать жизненный цикл изображений и учётных записей в системе. Пользователю с ролью ADMIN достаточно открыть панель, чтобы получить доступ ко всем функциям управления. В дополнение к перечисленным действиям панель может отображать различные предупреждения о статусе хранилища (например, нехватка свободного места или повышенная нагрузка на сервис сжатия) и предоставлять статистические отчёты в наглядном виде, упрощая принятие решений.

     Если говорить детальнее, то просмотр каталога (рисунок 3.4) даёт удобную сводку по всем загруженным в систему файлам: список записей из таблицы images, где каждый элемент может быть отсортирован по дате загрузки, уровню сжатия или названию. Фильтрация по имени или содержимому позволяет быстро найти нужный файл среди множества, а сама страница каталога может отображать как текстовые данные, так и небольшие превью изображений для более наглядной идентификации.

     Загрузка новых изображений (рисунок 3.5) обычно реализуется через простую форму, где администратор указывает путь к файлу на локальном компьютере и, при необходимости, подбирает настройки сжатия (или оставляет их по умолчанию). Система конвертирует файл в формат WebP и сохраняет результат в MinIO, дополнительно внося запись в таблицу images. В этот момент возможно автоматически установить начальный уровень сжатия, присвоив, к примеру, compressionLevel = 0 (минимальная компрессия), чтобы качественные файлы были доступны сразу, а решение о дальнейшем их ужимании принималось уже по итогам статистики.

     Раздел просмотра статистики (рисунок 3.6) может представлять собой не только таблицу с полями из image\_statistics, но и визуализировать данные в виде графиков — например, динамику изменения количества просмотров за последние дни, а также показывать общее количество скачиваний. Администратор видит актуальные цифры (viewCount, downloadCount), время последнего обращения, и при необходимости может насильно изменить уровень сжатия («зашкаливающая» популярность требует большего качества, а резкое снижение — более агрессивного ужимания).

     В части операций над уже загруженными изображениями (удаление, дублирование, переименование, смена формата) администратор сам решает, какие именно манипуляции провести. Если удалить файл, система удаляет соответствующую запись в images и объект в MinIO; при дублировании создаёт новую запись (с тем же или иным значением compressionLevel), а при переименовании обновляет поле originalFilename. Для смены формата возможно повторное перекодирование в WebP (с иными настройками сжатия) либо в другой формат (например, PNG), в зависимости от нужд сервиса.

     Управление пользователями охватывает ряд функций: просмотр списка учётных записей, где каждая соответствует строке в таблице users; изменение ролей, что происходит за счёт вставки или удаления записей в user\_roles; а также активация или блокировка пользователя путём переключения поля is\_enabled (false означает, что данный аккаунт не может авторизоваться в системе). Такая модель упрощает поддержку любого количества ролей — достаточно внести новую запись в таблицу roles, а затем привязать её к конкретным пользователям.

     В результате, админ-панель становится универсальным инструментом контроля: она интегрируется с микросервисами статистики, сжатия, аутентификации и напрямую взаимодействует с таблицами images, image\_statistics, users, roles и user\_roles. Она позволяет не только оперативно решать возникающие задачи (например, быстро освободить место путём сжатия или удаления старых файлов), но и заблаговременно планировать улучшения качества для наиболее посещаемых изображений, обеспечивая сбалансированное использование ресурсов.

     ![](Aspose.Words.2a035dbb-cfc3-4f17-912d-f297c388dd68.004.png)

     *Рис. 3.4 – Просмотр каталога изображений.*

     ![Изображение выглядит как текст, снимок экрана, Шрифт

Контент, сгенерированный ИИ, может содержать ошибки.](Aspose.Words.2a035dbb-cfc3-4f17-912d-f297c388dd68.005.png)

     *Рис. 3.5 – Загрузка изображения.*

     ![Изображение выглядит как текст, снимок экрана, Шрифт

Контент, сгенерированный ИИ, может содержать ошибки.](Aspose.Words.2a035dbb-cfc3-4f17-912d-f297c388dd68.006.png)

     *Рис. 3.*6 *– Статистика и сжатие.*

     Каждая операция (удаление, дублирование) вызывает REST-методы в микросервисе хранения. Система проверяет JWT: если нет роли ADMIN, возвращает ошибку доступа [3].
     ### <a name="_toc195554530"></a>**3.2.3 Динамика сжатия и статистика**
     Микросервис статистики каждые N часов (или по событию) анализирует поле (viewCount + downloadCount) за период (например, 7 дней) из image\_statistics. Если показатель низок, сервис повышает compressionLevel (сжимает сильнее); при росте популярности — наоборот, понижает compressionLevel. Поле originalImageId даёт возможность хранить исходное качество и «возвращаться» к нему при необходимости (например, сервис копирует файл из MinIO-объекта оригинала).

     Такое динамическое сжатие снижает объём занимаемого места и расходы на хранение, сохраняя высокое качество для популярных файлов.

     Динамическое сжатие позволяет системе более разумно расходовать дисковое пространство и при этом сохранять высокое качество для действительно востребованных изображений. Микросервис статистики периодически собирает сведения о просмотрах и скачиваниях каждого файла, затем рассчитывает показатель популярности (например, суммарный счётчик за последние 7 дней). 

     Если выявляется, что интерес пользователей к определённому изображению упал, то система увеличивает коэффициент сжатия и заново перекодирует файл, что позволяет уменьшить его размер на диске. При этом всегда хранится ссылка на «оригинал», чтобы в случае внезапного роста популярности можно было вернуться к исходному качеству.

     Для компрессии задействуется формат WebP, поскольку он даёт высокое соотношение «качество-объём» по сравнению с классическими JPEG и PNG. При таком подходе новое изображение при загрузке может быть конвертировано в WebP и сохранено в MinIO, а при изменении уровня сжатия – более жёстко упаковано, но при этом всё ещё сохранит визуально приемлемое качество. 

     Формат WebP выгодно отличается от более традиционных JPEG и PNG благодаря своему универсальному набору свойств: он поддерживает сжатие с потерями и без, умеет работать с альфа-каналом, а также обычно даёт на выходе меньший размер файла при сопоставимом качестве. 

     JPEG был создан давно и хорошо справляется со «фотографическими» сюжетами, но в нём отсутствует поддержка прозрачности, а артефакты сжатия иногда заметны даже при высоких настройках качества. 

     PNG, напротив, не теряет данные, но генерирует большие файлы и не столь эффективен при работе с детализированными полутоновыми изображениями. WebP сочетает сильные стороны обоих подходов: при сравнении с JPEG демонстрирует в среднем на 20–30% меньший размер, сохраняя визуально схожее качество, а прозрачность реализована более компактно, чем у PNG. 

     Дополнительным плюсом является активное развитие: движки браузеров уже давно поддерживают WebP, и даже при работе с локальными хранилищами в большинстве современных библиотек есть инструменты для его быстрого кодирования/декодирования. Именно совокупность этих факторов делает WebP оптимальным форматом для системы, где важна комбинация хорошего визуального результата и сокращения объёмов хранения.

     Если система замечает, что за последние сутки или неделю счётчик обращений к файлу резко увеличился, уровень сжатия снижается, а в качестве основы берётся более «тяжёлый», но чёткий исходник.

     Таким образом, редко используемые файлы автоматически переходят в максимально сжатый формат, а популярные изображения держатся в состоянии минимального сжатия. 

     С точки зрения пользователей и интерфейсов ничего не меняется: они запрашивают всё по одному и тому же идентификатору, а сама логика «горячего» и «холодного» хранения остаётся внутри микросервиса, управляемого данными из таблицы image\_statistics. Это не только помогает сокращать расходы на хранение (особенно в сценариях с огромными коллекциями файлов), но и даёт гибкость в управлении качеством.

     ![Изображение выглядит как текст, диаграмма, линия, снимок экрана

Контент, сгенерированный ИИ, может содержать ошибки.](Aspose.Words.2a035dbb-cfc3-4f17-912d-f297c388dd68.007.png)На рисунке 3.7 представлен алгоритм сжатия и ранжирования в виде схемы.

     *Рис. 3.*7 *– Алгоритм сжатия и ранжирования.*




































     # <a name="_toc184074457"></a><a name="_toc184148703"></a><a name="_toc195554531"></a>**СПИСОК ИСПОЛЬЗОВАННЫХ ИСТОЧНИКОВ**

1. <a name="_hlk184147832"></a>Васильев, А.Н. Java. Объектно-ориентированное программирование: Учебное пособие: для магистров и бакалавров. Базовый курс по объектно-ориентированному программированию / А.Н. Васильев. - СПб.: Питер, 2013. - 400 c.
1. Блох, Дж. Java: эффективное программирование / Дж. Блох. - М.: Диалектика, 2019. - 464 c.
1. Давыдов, С. IntelliJ IDEA. Профессиональное программирование на Java / С. Давыдов. - СПб.: BHV, 2005. - 800 c.
1. Docker, T. Docker Documentation [Электронный ресурс] / T. Docker. —

   2015\. — URL: https://media.readthedocs.org/pdf/dhrpdocs/stable/dhrpdocs.pdf (Дата Обращения 02.12.2024).

1. Курняван, Б. Программирование WEB-приложений на языке Java / Б. Курняван. - М.: Лори, 2014. - 880 c. 



